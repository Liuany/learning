# 语法

## 注释

#### 单行注释

```java
// 这是一段单行注释
```

#### 多行注释

```java
/*
这是多行注释的第一行
这是多行注释的第二行
这是多行注释的第三行
这是多行注释的第四行
这是多行注释的第五行
*/
```

```java
/**
*这是多行注释的第二种方式，可以为注释添加说明
*@Description 描述
*@Author 作者是谁
*/
```



## 关键字

> Java关键字是预先定义的具有特别意义的标识符，也可以叫Java保留字，Java关键字不能用作变量名、方法名、类名包名和参数

| Java关键字类别       | Java关键字   | 关键字含义                                                   |
| -------------------- | ------------ | ------------------------------------------------------------ |
| 访问控制             | private      | 一种访问控制方式：私用模式，访问控制修饰符，可以应用于类、方法或字段（在类中声明的变量） |
| 访问控制             | protected    | 一种访问控制方式：保护模式，可以应用于类、方法或字段（在类中声明的变量）的访问控制修饰符 |
| 访问控制             | public       | 一种访问控制方式：共用模式，可以应用于类、方法或字段（在类中声明的变量）的访问控制修饰符。 |
| 类、方法和变量修饰符 | abstract     | 表明类或者成员方法具有抽象属性，用于修改类或方法             |
| 类、方法和变量修饰符 | class        | 声明一个类，用来声明新的Java类                               |
| 类、方法和变量修饰符 | extends      | 表明一个类型是另一个类型的子类型。对于类，可以是另一个类或者抽象类；对于接口，可以是另一个接口 |
| 类、方法和变量修饰符 | final        | 用来说明最终属性，表明一个类不能派生出子类，或者成员方法不能被覆盖，或者成员域的值不能被改变，用来定义常量 |
| 类、方法和变量修饰符 | implements   | 表明一个类实现了给定的接口                                   |
| 类、方法和变量修饰符 | interface    | 接口                                                         |
| 类、方法和变量修饰符 | native       | 用来声明一个方法是由与计算机相关的语言（如C/C++/FORTRAN语言）实现的 |
| 类、方法和变量修饰符 | new          | 用来创建新实例对象                                           |
| 类、方法和变量修饰符 | static       | 表明具有静态属性                                             |
| 类、方法和变量修饰符 | strictfp     | 用来声明FP_strict（单精度或双精度浮点数）表达式遵循IEEE 754算术规范 |
| 类、方法和变量修饰符 | synchronized | 表明一段代码需要同步执行                                     |
| 类、方法和变量修饰符 | transient    | 声明不用序列化的成员域                                       |
| 类、方法和变量修饰符 | volatile     | 表明两个或者多个变量必须同步地发生变化                       |
| 程序控制             | break        | 提前跳出一个块                                               |
| 程序控制             | continue     | 回到一个块的开始处                                           |
| 程序控制             | return       | 从成员方法中返回数据                                         |
| 程序控制             | do           | 用在do-while循环结构中                                       |
| 程序控制             | while        | 用在循环结构中                                               |
| 程序控制             | if           | 条件语句的引导词                                             |
| 程序控制             | else         | 用在条件语句中，表明当条件不成立时的分支                     |
| 程序控制             | for          | 一种循环结构的引导词                                         |
| 程序控制             | instanceof   | 用来测试一个对象是否是指定类型的实例对象                     |
| 程序控制             | switch       | 分支语句结构的引导词                                         |
| 程序控制             | case         | 用在switch语句之中，表示其中的一个分支                       |
| 程序控制             | default      | 默认，例如：用在switch语句中，表明一个默认的分支。Java8 中也作用于声明接口函数的默认实现 |
| 错误处理             | try          | 尝试一个可能抛出异常的程序块                                 |
| 错误处理             | catch        | 用在异常处理中，用来捕捉异常                                 |
| 错误处理             | throw        | 抛出一个异常                                                 |
| 错误处理             | throws       | 声明在当前定义的成员方法中所有需要抛出的异常                 |
| 包相关               | import       | 表明要访问指定的类或包                                       |
| 包相关               | package      | 包                                                           |
| 基本类型             | boolean      | 基本数据类型之一，声明布尔类型的关键字                       |
| 基本类型             | byte         | 基本数据类型之一，字节类型                                   |
| 基本类型             | char         | 基本数据类型之一，字符类型                                   |
| 基本类型             | double       | 基本数据类型之一，双精度浮点数类型                           |
| 基本类型             | float        | 基本数据类型之一，单精度浮点数类型                           |
| 基本类型             | int          | 基本数据类型之一，整数类型                                   |
| 基本类型             | long         | 基本数据类型之一，长整数类型                                 |
| 基本类型             | short        | 基本数据类型之一,短整数类型                                  |
| 基本类型             | null         | 空，表示无值，不能将null赋给原始类型（byte、short、int、long、char、float、double、boolean）变量 |
| 基本类型             | true         | 真，boolean变量的两个合法值中的一个                          |
| 基本类型             | false        | 假，boolean变量的两个合法值之一                              |
| 变量引用             | super        | 表明当前对象的父类型的引用或者父类型的构造方法               |
| 变量引用             | this         | 指向当前实例对象的引用，用于引用当前实例                     |
| 变量引用             | void         | 声明当前成员方法没有返回值，void可以用作方法的返回类型，以指示该方法不返回值 |
| 保留字               | goto         | 保留关键字，没有具体含义                                     |
| 保留字               | const        | 保留关键字，没有具体含义，是一个类型修饰符，使用const声明的对象不能更新 |



## 标识符

> 在java语言中，标识符常用来给类、对象、变量、方法、接口、自定义数据类型等命名的。

#### 标识符命名规则

- 所有标识符都应该以字母（A-Z 或者 a-z），美元符($)、或者下划线(_)开始
- 首字符之后可以是字母（A-Z 或者 a-z），美元符($)、或者下划线(_)或数字的任何字符组合
- 不能使用关键字作为变量名或方法名
- 标识符是==大小写敏感==的

```java
public class Tags {
    // 这里myName是一个标识符
    private String myName = "'Jobs'";

    public static void main(String[] args) {
        // 这里的bean是一个标识符
        Tags bean = new Tags();
        bean.getName();
    }

    public void getName() {
        System.out.println("my name is " + this.myName);
    }
}
```



##  数据类型

> 强类型语言：要求变量的使用要严格符合规定，所有变量都必须先定义后才能使用。

> 若类型语言：例如javaScript。其数据的使用更加自由，效率更高，但安全性差。

#### 基本数据类型

###### 八大基本数据类型

- 整数类型：

  byte：-2^7 ~ 2^7-1，即-128 ~ 127。1字节。Byte。末尾加B。

  short：-2^15 ~ 2^15-1，即-32768 ~ 32767。2字节。Short。末尾加S。

  int：-2^31 ~ 2^31-1，即-2147483648 ~ 2147483647。4字节。Integer。

  long：-2^63 ~ 2^63-1，即-9223372036854774808 ~ 9223372036854774807。8字节。Long。末尾加L。（也可以不加L）

- 浮点类型：

  float：4字节。Float。末尾加F。（也可以不加F）

  double：8字节。Double。

- 字符类型：

  char：2字节。Character。

- 布尔类型：

​		bealon：true & false

```java
// 整型
byte num1 = 20;
short num2 = 100;
int num3 = 100001;
long num4 = 200000000000l;

// 浮点型
float str1 = 4.1f;
double str2 = 3.1415926;

// 字符型
char letter = 'A';

// 布尔型
boolean isAuth = true;
boolean access = false;
```

```Java
/**
* @ Description:基本数据类型拓展
* @ Author: Kevin
* @ Date: 2022-07-18
*/
public static void expand(){
    // 整型拓展： 二进制：0b   八进制：0   十六进制：0x
    int num1 = 10;  // 十进制
    int num2 = 0b10;    // 二进制
    int num3 = 010;    //八进制
    int num4 = 0x10;    //十六进制

    System.out.println("****************************整型拓展begin****************************");
    System.out.println("十进制[10]：" + num1);   // 10
    System.out.println("二进制[0b10]：" + num2);   // 2
    System.out.println("八进制[010]：" + num3);   // 8
    System.out.println("十六进制[0x10]：" + num4);   // 16
    System.out.println("*****************************整型拓展end*****************************\n");

    // 浮点型拓展
    // 由于float数据类型是一个有限的、离散的、含误差的、大约的、接近但不等于的数据，因为用来作比较时常常会引发误差
    // 解决方法为避免使用float来作比较，使用BigDecimal类来进行比较
    // 转义字符：eg:\t 制表符  \n 换行符 ...
    float f = 0.1f;
    double d = 1.0 / 10;

    float f1 = 12346542134654654f;
    float f2 = f1 + 1;
    System.out.println("****************************浮点拓展begin****************************");
    System.out.println(f);
    System.out.println(d);
    System.out.println(f == d);
    System.out.println(f1 == f2);
    System.out.println("*****************************浮点拓展end*****************************\n");

    // 字符拓展
    // 字符的本质是整型，因此可以进行相互转换和比较，其对比的规则是参照Unicode表
    // Unicode编码：Unicode表 97 = a 65 = A
    // 补充：excel最初的版本最多只能有2^16=65536行数据
    char c1 = 'a';
    char c2 = '中';
    char c3 = '\u0061'; // Unicode编码
    System.out.println("****************************字符拓展begin****************************");
    System.out.println(c1);
    System.out.println((int) c1);    // 强制转换
    System.out.println(c2);
    System.out.println((int) c2);    // 强制转换
    System.out.println(97 == c1);   // 不作强制转换依然相等
    System.out.println((int) 'A');  // 65
    System.out.println(c3);
    System.out.println("*****************************字符拓展end*****************************\n");
}
```



###### 字节

> 字节（Byte）是计算机信息技术用于计量存储容量的一种计量单位，也表示一些计算机编程语言中的数据类型和语言字符 。一个字节存储8位无符号数，储存的数值范围为0-255。如同字元一样，字节型态的变数只需要用一个位元组（8位元）的内存空间储存。

- 位（bit）：计算机内部储存的最小单位，eg：11001100是一个八位二进制数。
- byte（位）：是计算机中数据处理的基本单位，习惯上用B来表示。
- 1B（byte）= 8bit（位）
- 字符：是指计算机中使用的字母、数字、字和符号

> 1bit表示一位	1Byte表示一个字节 1B = 8b	1024B = 1KB	1024KB = 1M	1024M = 1G	1024G = 1T 



###### 基本类型间的转换

> 由于Java是强语言类型语言，所以要进行有些运算的时候，需要用到类型转换。

- 不能对布尔值进行转换。
- 不能把对象类型转成不相干的类型。
- 把高容量类型转换成低容量类型时，需要强制转换，==低容量类型转换成高容量类型时则自动转换==。
- 转换时可能出现内存溢出或者精度问题。

```java
/**
* @ Description:类型转换
* @ Author: Kevin
* @ Date: 2022-07-18
*/
public static  void transform() {
    // 由于Java是强语言类型语言，所以要进行有些运算的时候，需要用到类型转换
    // 不能对布尔值进行转换
    // 不能把对象类型转成不相干的类型
    // 把高容量类型转换成低容量类型时，需要强制转换，低容量类型转换成高容量类型时则自动转换
    // 转换时可能出现内存溢出或者精度问题

    // 由高转低
    int i  = 128;
    byte b = (byte) i;  // 内存溢出
    System.out.println(b);  // -128,由于byte的最大值为127，但强转的值大于最大值时，将出现内存溢出或者精度问题

    System.out.println((int) 36.5);     //36
    System.out.println((int) -45.12f);  //-45 向上取整

    char c = 'a';
    int d = c + 1;
    System.out.println(d);  //98
    System.out.println((char) d);   //b

    // JDK7新特性，数字之间可以用下划线分割
    int salary = 1000_000_000;
    int years = 20;
    int total = years * salary;     // 超过int最大值，内存溢出
    long total1 = years * salary;   // 计算完之后再作强制转换是将溢出后的值进行转换
    long total2 = years * (long)salary;     // 先作转换，解决了精度问题后再计算，结果正确
    System.out.println(total);  // -1474836480
    System.out.println(total1); // -1474836480
    System.out.println(total2); // 20000000000
}
```



## 变量

> 变量就是可以变化的量，在内存中定义一块区域，其值可以改变。

- Java是一种强类型语言，每个变量都必须声明其类型，类型可以是基本类型，也可以是引用类型。
- Java变量是程序中最基本的存储单元，其要素包括变量名，变量类型和作用域。
- 可以使用逗号分割开来声明多个变量，==但不建议这么做==。
- 变量名必须是合法的标识符。
- 变量声明是一条完整的语句，因此每一个声明都必须以分好结束。

#### 类变量

> 类变量定义在类内，方法体之外，必须用static修饰词进行修饰，作用域为整个类。

#### 实例变量

> 也称之为成员变量，定义在类内，方法体之外，作用域为整个类。

#### 局部变量

> 定义在方法体内，必须声明和初始化，其作用域仅限于方法体。

#### 常量

> 常量的隶属于类，其生命周期与类同步，常量一旦定义其值就不可以改变。

#### 变量命名规则

- 所有变量、方法、类名都应==见名知意==
- 类成员变量：首字母小写和驼峰原则：monthSalary，除第一个字母小写外，后面单词的首字母大写
- 局部变量：首字母小写和驼峰原则
- 常量：大写字母和下划线：MAX_VALUE
- 类名：首字母大写和驼峰原则：Father，GodFather
- 方法名：首字母小写和驼峰原则



## 运算符

- 算术运算符：+，-，*，/，%，++，--
- 赋值运算符：=
- 关系运算符：>，<，>=，<=，!=，instanceof
- 逻辑运算符：&&，||，!
- 条件运算符（三目表达式）：条件语句 ? [如果为真] 结果1 : [如果为假] 结果2
- 扩展赋值运算：+=，-=，*=，/=



##面向对象

#### 内部类

> 将一个类定义在一个类或者一个方法里，这样的类就称之为内部类。

- 成员内部类

  1、成员内部类是最普通的一种内部类，可以调用外部内的所有方法和属性，外部类要调用内部类的方法则必须先实例化内部类。

  2、成员内部类不能包含静态属性和方法。

  3、成员内部类的成员变量与方法允许与外部类重名，但这么做的话需要使用『外部类名.this』进行访问

  ```java
  public class Outer_01 {
      // 成员变量
      private String claim = "我是外部类";
      // 成员方法
      public void display(){
          System.out.println("我是外部类的方法");
      }
      // 成员内部类
      public class Inner {
          // 成员变量
          private String claim;
          // 内部类构造方法
          public Inner() {
              this.claim = "我是成员内部类";
          }
          // 成员方法
          public void display(){
              // 访问内部类的成员变量
              System.out.println("访问内部类的成员变量：" + claim);
              // 访问外部类的成员变量
              System.out.println("访问外部类的成员变量：" + Outer_01.this.claim);
              // 访问外部类的方法
              Outer_01.this.display();
          }
      }
  }
  
  // 一个java文件中定义两个类时只能有一个类被public修饰，且该类名必须与文件名一致
  class Test01{
      public static void main(String[] args) {
          // 实例化外部类对象
          Outer_01 outer = new Outer_01();
          //调用外部类方法
          outer.display();
          //实例化外部类对象
          Outer_01.Inner inner = outer.new Inner();
          //调用内部类方法
          inner.display();
      }
  }
  ```

- 局部内部类

  1、定义在代码块里的类，比如定义在一个方法中。

  2、起作用的范围仅限于它所在的代码块中。

  3、局部内部类不能被pubic、protected、private、static修饰，但是可以被final修饰。

  ```java
  public class Outer_02 {
      // 成员变量
      private String claim = "我是外部类";
      // 成员方法
      public void display(){
          class Inner {
              private String claim;
  
              public Inner(){
                  this.claim = "我是局部内部类";
              }
  
              public void display(){
                  System.out.println("我是局部内部类");
              }
          }
          // 局部内部类定义在外部内的方法体或者代码块中，在方法体重可以实例化局部内部类，调用局部内部类中的方法。
          Inner inner = new Inner();
          inner.display();
      }
  }
  
  class Test02{
      public static void main(String[] args) {
          // 实例化外部类
          Outer_02 outer = new Outer_02();
          // 实例化内部类
          outer.display();
      }
  }
  ```

- 静态内部类

  与成员内部类相比多了static关键字的修饰，静态内部类只能访问外部内的静态变量和静态方法。

  ```java
  public class Outer_03 {
      // 成员变量
      public static String claim = "我是外部类";
      // 成员方法
      public static void display(){
          System.out.println("我是外部类的方法");
      }
      // 静态内部类
      public static class Inner{
          // 成员变量
          private String claim;
          // 内部类构造方法
          public Inner() {
              this.claim = "我是成员内部类";
          }
          // 成员方法
          public void display(){
              // 访问内部类的成员变量
              System.out.println("访问内部类的成员变量：" + claim);
              // 访问外部类的静态成员变量
              System.out.println("访问外部类的成员变量：" + Outer_03.claim);
              // 访问外部类的静态方法
              Outer_03.display();
          }
      }
  }
  
  class Test03{
      public static void main(String[] args) {
          // 访问外部内成员变量
          System.out.println(Outer_03.claim);
          //访问外部类方法
          Outer_03.display();
          // 不再需要实例化外部内便可实例化内部类
          Outer_03.Inner inner = new Outer_03.Inner();
          inner.display();
      }
  }
  ```

- 匿名内部类

  1、匿名内部类是没有名称的内部类。

  2、当一个类需要继承一个类或者实现一个接口时（必要条件），并且只使用一次的时候，可以考虑这种方式。

  3、调用的时候直接使用父类的无参构造，并重写父类方法，从而达到优化代码的目的。

  ```java
  // 创建一个接口
  public interface MyInterface {
      public void display();
  }
  
  //实现一个内部类
  public class Outer_04 {
      public static void main(String[] args) {
          // 匿名内部类
          MyInterface myInterface = new MyInterface() {
              @Override
              public void display() {
                  System.out.println("匿名内部类");
              }
          };
          myInterface.display();  //匿名内部类
      }
  }
  ```
